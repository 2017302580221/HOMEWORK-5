### UDP16位校验和

此作业要求先对3个16位的二进制数据依次求和，若有溢出则回卷，最终得到的结果取反即为校验和。 校验和与其他三个16位数据相加，若结果中存在一位不为1的数据则说明有数据传输错误。

首先16位数据依次相加，若有溢出则回卷

pic1

最后得到值，需要取反，只需要与0xffff进行异或运算即可

返回最后的的结果

具体代码看py文件

---


### 习题P3

首先相加：01010011+01100110 = 10111001

10111001+01110100, 有溢出，最后低位加1，得到结果：00101110

反码：11010001

使用反码能够计算校验和比较简单快速，而且不依赖计算机系统是大端还是小端

接收方检验差错是将三个字节与检验和相加，若得出的最后二进制数据中任何一位为0，则出错

1比特的差错肯定会导致结果不同

2比特的差错可能会检测不出

---

### 习题P12

当仅有一个比特差错时，协议能够正常工作，但是可能比 rdt3.0 发送方反应更快。
当定时器时间过短时，每一个超时重发的分组都将会导致正在发送的包重发，这样从第一个包累积到第n个包，分组发送的次数将趋于无穷。