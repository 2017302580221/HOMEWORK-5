用python实现UDP的16位校验和，并检测3.3.2节的例子
python源码如下：
def CheckSum(list):
    sum=0
    for l in list:#对list中每个16位数
        if len(l)!=16:
            print("数据来源中某项不为16位，请检查数据")
            return -1#错误时返回-1
        sum+=int(l,2)#将每个16位数转化为10进制数然后再加减
        sum=(sum&0xffff)+(sum>>16)#回卷运算
    return sum^(0xffff)#取反返回

if __name__=='__main__':
    list=["0110011001100000",
          "0101010101010101",
          "1000111100001100"]
    actSum="1011010100111101"
    calSum=bin(CheckSum((list))).replace("0b","")#将获得的校验和转化为2进制并删除开头
    for i in range(0,len(list)):
        print("第"+str(i+1)+"个16位数字是"+list[i])
    print("预测校验和是"+calSum)
    print("真实检验和是"+actSum)
    if actSum==str(calSum):
        print("预测值和真实值相等")
    else:
        print("预测值和真实值不等")
结果如下：
![image](https://github.com/20192021855-DCAN/HOMEWORK-5/new/master/2017301110061/image/UDPCheck.png)  

课后习题:  
P3   
UDP和TCP使用反码来计算它们的检验和。假设你有下面3个8比特字节：01010011, 01100110, 01110100.这些8比特字节和的反码是多少？
（注意到尽管UDP和TCP使用16比特的字来计算检验和，但对于这个问题，你应该考虑8比特和。）
写岀所有工作过程。UDP为什么要用该和的反码，即为什么不直接使用该和呢？使用该反码方案，接收方如何检测出差错？ 
1比特的差错将可能检测不出来吗？ 2比特的差错呢？ 
 01010011  
+01100110
=10111001
+01110100
=100101101=00101110(回转）=11010001(取反）
好处：可以不考虑大端小端，简单方便。
检查差错：看最后结果是否有0，有0则有错。1bit差错不可能检查不出来，2bit可能检查不出来。
P4
 a.假定你有下列2个字节：01011100和01100101这2个字节之和的反码是什么？ 
 b. 假定你有下列2个字节：11011010和0ll00l0l这2个字节之和的反码是什么？
 c. 对于（a）中的字节，给出一个例子，使得这2个字节中的每一个都在一个比特反转时，其反码不会改变.  
 answer：
 a.01011100
  +01100101
  =11000001=00111110（取反)  
 b.11011010
  +01100101
  =01000000=10111111(取反）  
 c.第一个字节=01010100；第二个字节=01101101。

