#第五次作业 
**检验UDP16位校验和**	  
比较直接，依次相加，有溢出就回溯，得到结果后取反，检验部分按照书上数据来就行（并未使用matplot）  

**P3: UDP和TCP使用反码来计算它们的检验和。假设你有下面3个8比特字节：01010011, 01100110, 01110100.这些8比特字节和的反码是多少？（注意到尽管UDP和TCP使用16比特的字来计算检验 和，但对于这个问题，你应该考虑8比特和。）写岀所有工作过程。UDP为什么要用该和的反码，即 为什么不直接使用该和呢？使用该反码方案，接收方如何检测出差错？ 1比特的差错将可能检测不出 来吗？ 2比特的差错呢？**  
解答：   01010011   
+   01100110   
————————————  
    10111001  
+   01110100  
————————————  
(1) 00101101  
+          1  
————————————  
    00101110
取反码，11010001  
用反码不用考虑系统是大端还是小端  
接收方检验时只需要将三个字节与检验和相加，如果任何一个位为 0，说明出错  
1bit一定能检测出来，但是2bit时尾bit反转可能出现查不出来的情况  

**P4: a.假定你有下列2个字节：01011100和01100101Q这2个字节之和的反码是什么？ b. 假定你有下列2个字节：11011010和0llOOlOlo这2个字节之和的反码是什么？ c. 对于（a）中的字节，给出一个例子，使得这2个字节中的每一个都在一个比特反转时，其反码不 会改变。 **  
a. 00111110  
b. 01000000  
c. a 中基础数据变为 01011101、01100100
